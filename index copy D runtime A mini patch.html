<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Function Graph 3D</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #0b0f14; }

    .hudbox {
      position: fixed;
      top: 64px;
      color: #cfd8dc;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-size: 13px;
      line-height: 1.3;
      background: rgba(20, 24, 31, 0.75);
      padding: 8px 10px;
      border-radius: 8px;
      white-space: pre;
      pointer-events: none;
      z-index: 2;
      max-width: 30vw;
    }

    #hud_left { left: 12px; }
    #hud_center { left: 50%; transform: translateX(-50%); text-align: center; }
    #hud_right { right: 12px; text-align: right; }

    #topbar {
      position: fixed;
      left: 0;
      right: 0;
      top: 0;
      height: 52px;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      background: rgba(10, 12, 16, 0.85);
      backdrop-filter: blur(6px);
      z-index: 3;
    }

    #tabs {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .tabbtn {
      pointer-events: auto;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(20, 24, 31, 0.75);
      color: #cfd8dc;
      padding: 7px 10px;
      border-radius: 8px;
      font-size: 13px;
      cursor: pointer;
      user-select: none;
    }

    .tabbtn.active {
      border-color: rgba(255,255,255,0.30);
      background: rgba(40, 46, 58, 0.85);
      color: #ffffff;
    }

    #runtime_controls {
      display: none;
      align-items: center;
      gap: 8px;
      margin-left: 10px;
    }

    .ctlbtn {
      pointer-events: auto;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(20, 24, 31, 0.75);
      color: #cfd8dc;
      padding: 7px 10px;
      border-radius: 8px;
      font-size: 13px;
      cursor: pointer;
      user-select: none;
      min-width: 34px;
      text-align: center;
    }

    .ctlbtn:active {
      transform: translateY(1px);
    }

    #rt_step {
      color: #cfd8dc;
      font-size: 12px;
      opacity: 0.85;
      padding: 0 6px;
      white-space: nowrap;
    }

    #rt_speed {
      pointer-events: auto;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(20, 24, 31, 0.75);
      color: #cfd8dc;
      padding: 7px 10px;
      border-radius: 8px;
      outline: none;
      font-size: 13px;
    }

    #rt_steps {
      margin-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.10);
      padding-top: 10px;
    }

    .rtrow {
      display: grid;
      grid-template-columns: 70px 1fr;
      gap: 10px;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      cursor: pointer;
    }

    .rtrow:hover { background: rgba(255,255,255,0.04); }

    .rtrow .ln { opacity: 0.8; font-variant-numeric: tabular-nums; }
    .rtrow .txt { color: #ffffff; }
    .rtrow.active { background: rgba(255,255,255,0.06); }

    #search {
      pointer-events: auto;
      width: 320px;
      max-width: 44vw;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(20, 24, 31, 0.75);
      color: #cfd8dc;
      padding: 8px 10px;
      border-radius: 8px;
      outline: none;
      font-size: 13px;
    }

    #listpanel {
      position: fixed;
      left: 12px;
      right: 12px;
      top: 64px;
      bottom: 12px;
      background: rgba(10, 12, 16, 0.82);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      overflow: hidden;
      display: none;
      z-index: 3;
      pointer-events: auto;
    }

    #runtimepanel {
      position: fixed;
      left: 12px;
      right: 12px;
      top: 64px;
      bottom: 12px;
      background: rgba(10, 12, 16, 0.82);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      overflow: hidden;
      display: none;
      z-index: 3;
      pointer-events: auto;
    }

    .panelhead {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      display: flex;
      gap: 10px;
      align-items: baseline;
      color: #cfd8dc;
      font-size: 13px;
    }

    .panelhead .meta {
      opacity: 0.8;
      font-size: 12px;
    }

    .panelbody {
      height: calc(100% - 44px);
      overflow: auto;
      padding: 12px;
      color: #cfd8dc;
      font-size: 13px;
    }

    #list {
      height: calc(100% - 44px);
      overflow: auto;
      padding: 6px 0;
      background: transparent;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 110px 110px 120px;
      gap: 10px;
      padding: 8px 12px;
      color: #cfd8dc;
      font-size: 13px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      cursor: pointer;
    }

    .row:hover {
      background: rgba(255,255,255,0.04);
    }

    .row .name { color: #ffffff; }
    .row .muted { opacity: 0.85; text-align: right; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
<div id="hud_left" class="hudbox">Loading...</div>
<div id="hud_center" class="hudbox"> </div>
<div id="hud_right" class="hudbox"> </div>

<div id="topbar">
  <div id="tabs">
    <div id="domain_functions" class="tabbtn active">Functions</div>
    <div id="domain_runtime" class="tabbtn">Runtime</div>
    <div style="width:12px"></div>
    <div id="view_3d" class="tabbtn active">3D View</div>
    <div id="view_list" class="tabbtn">List</div>
  </div>
  <input id="search" type="text" placeholder="Search functions..." style="display:none" />
  <div id="runtime_controls">
    <div id="rt_prev" class="ctlbtn">◀</div>
    <div id="rt_play" class="ctlbtn">Play</div>
    <div id="rt_next" class="ctlbtn">▶</div>
    <div id="rt_step">0 / 0</div>
    <select id="rt_speed">
      <option value="0.4">0.4x</option>
      <option value="0.7">0.7x</option>
      <option value="1" selected>1x</option>
      <option value="1.5">1.5x</option>
      <option value="2">2x</option>
    </select>
  </div>
</div>

<div id="listpanel">
  <div class="panelhead">
    <div>Functions</div>
    <div class="meta" id="listmeta"></div>
  </div>
  <div id="list"></div>
</div>
<div id="runtimepanel" style="display:none">
  <div class="panelhead">
    <div>Runtime</div>
    <div class="meta">(live / sampled execution data)</div>
  </div>
  <div class="panelbody">
    Runtime logic playback (derived from callsite line order).

    <div id="rt_info"></div>
    <div id="rt_steps"></div>
  </div>
</div>

<script type="module">

/*
{
  "globals": {
    "imports": [
      "string"
    ],
    "global_vars": [
      "string"
    ],
    "constants": [
      "string"
    ]
  },
  "functions": [
    {
      "function_name": "string",
      "start_line": 0,
      "line_count": 0,
      "end_line": 0,
      "desc": "string",
      "invokes": {
        "total": 0,
        "invoke_list": [
          {
            "line": 0,
            "context": "single",
            "callee": "string",
            "args_preview": "string"
          },
          {
            "line": 0,
            "context": "loop",
            "loop_header_preview": "string",
            "callee": "string",
            "args_preview": "string"
          }
        ]
      },
      "inputs": {
        "args": [
          "string"
        ]
      },
      "locals": {
        "local_vars": [
          "string"
        ],
        "local_functions": [
          "string"
        ]
      },
      "writes": {
        "none": true,
        "targets": [
          "string"
        ]
      },
      "returns": {
        "none": true,
        "returns": [
          "string"
        ]
      }
    }
  ]
}
*/
import * as THREE from "three";
import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
let DATA = null;

function buildGraph(data)
{
  const funcs = data.functions || [];

  // Nodes by function name
  const nodes = [];
  const nodeByName = Object.create(null);

  for (let i = 0; i < funcs.length; i++)
  {
    const f = funcs[i];
    const name = f.function_name || ("fn_" + i);

    const start = (typeof f.start_line === "number") ? f.start_line : 0;
    const end = (typeof f.end_line === "number")
      ? f.end_line
      : ((typeof f.line_count === "number") ? (start + f.line_count - 1) : 0);

    const n = {
      id: name,
      name: name,
      start_line: start,
      end_line: end,
      out_calls: 0,
      in_calls: 0,
      x: (Math.random() - 0.5) * 400,
      y: (Math.random() - 0.5) * 400,
      z: (Math.random() - 0.5) * 400,
      vx: 0,
      vy: 0,
      vz: 0,
      r: 6,
      mesh: null
    };

    nodes.push(n);
    nodeByName[name] = n;
  }

  // Caller lookup by callsite line number
  const spans = nodes.slice().sort(function(a, b)
  {
    if (a.start_line !== b.start_line) return a.start_line - b.start_line;
    return a.end_line - b.end_line;
  });

  function findCallerByLine(line)
  {
    if (typeof line !== "number") return null;

    let lo = 0;
    let hi = spans.length - 1;
    let bestIdx = -1;

    while (lo <= hi)
    {
      const mid = (lo + hi) >> 1;
      const s = spans[mid].start_line;

      if (s <= line)
      {
        bestIdx = mid;
        lo = mid + 1;
      }
      else
      {
        hi = mid - 1;
      }
    }

    if (bestIdx < 0) return null;

    let best = null;
    for (let i = bestIdx; i >= 0; i--)
    {
      const n = spans[i];
      if (n.start_line > line) continue;
      if (n.end_line < line) break;

      if (!best) best = n;
      else
      {
        const bestSize = best.end_line - best.start_line;
        const nSize = n.end_line - n.start_line;
        if (nSize < bestSize) best = n;
      }
    }

    return best;
  }

  const edges = [];
  const edgeByKey = Object.create(null);
  let unresolvedCalls = 0;

  for (let i = 0; i < funcs.length; i++)
  {
    const f = funcs[i];
    const inv = (f.invokes && f.invokes.invoke_list) ? f.invokes.invoke_list : [];

    for (let k = 0; k < inv.length; k++)
    {
      const call = inv[k];
      const calleeName = call.callee;
      const calleeNode = calleeName ? nodeByName[calleeName] : null;

      if (!calleeNode)
      {
        unresolvedCalls++;
        continue;
      }

      const callerNode = findCallerByLine(call.line);
      if (!callerNode)
      {
        unresolvedCalls++;
        continue;
      }

      const key = callerNode.id + "->" + calleeNode.id;
      let e = edgeByKey[key];
      if (!e)
      {
        e = {
          s: callerNode,
          t: calleeNode,
          count: 0
        };
        edgeByKey[key] = e;
        edges.push(e);
      }

      e.count++;
      callerNode.out_calls++;
      calleeNode.in_calls++;
    }
  }

  for (let i = 0; i < nodes.length; i++)
  {
    const n = nodes[i];
    const calls = n.out_calls + n.in_calls;
    n.r = 3.5 + Math.sqrt(Math.max(0, calls)) * 1.6;
  }

  return {
    nodes: nodes,
    edges: edges,
    meta: {
      unresolved_calls: unresolvedCalls
    }
  };
}

function start3D(graph)
{
  const hudLeft = document.getElementById("hud_left");
  const hudCenter = document.getElementById("hud_center");
  const hudRight = document.getElementById("hud_right");

  const domainFunctions = document.getElementById("domain_functions");
  const domainRuntime = document.getElementById("domain_runtime");
  const view3d = document.getElementById("view_3d");
  const viewList = document.getElementById("view_list");
  const listPanel = document.getElementById("listpanel");
  const runtimePanel = document.getElementById("runtimepanel");
  const listEl = document.getElementById("list");
  const listMeta = document.getElementById("listmeta");
  const searchEl = document.getElementById("search");
  const rtControls = document.getElementById("runtime_controls");
  const rtPrev = document.getElementById("rt_prev");
  const rtPlay = document.getElementById("rt_play");
  const rtNext = document.getElementById("rt_next");
  const rtStepLabel = document.getElementById("rt_step");
  const rtSpeed = document.getElementById("rt_speed");
  const rtInfo = document.getElementById("rt_info");
  const rtStepsEl = document.getElementById("rt_steps");

  let domainMode = "functions";
  let viewMode = "3d";

  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x0b0f14, 800, 2600);

  const camera = new THREE.PerspectiveCamera(
    60,
    window.innerWidth / window.innerHeight,
    0.1,
    10000
  );
  camera.position.set(0, 0, 900);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  document.body.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.rotateSpeed = 0.6;
  controls.zoomSpeed = 0.9;

  const lightA = new THREE.AmbientLight(0xffffff, 0.55);
  scene.add(lightA);

  const lightB = new THREE.DirectionalLight(0xffffff, 0.85);
  lightB.position.set(1, 1, 1);
  scene.add(lightB);

  const nodeMat = new THREE.MeshStandardMaterial({ color: 0x4fb3ff });
  const hoverMat = new THREE.MeshStandardMaterial({ color: 0xcfe8ff });
  const selMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
  const rtActiveMat = new THREE.MeshStandardMaterial({ color: 0xffd54f });
  const rtCalleeMat = new THREE.MeshStandardMaterial({ color: 0xff8a65 });

  const meshes = [];
  for (let i = 0; i < graph.nodes.length; i++)
  {
    const n = graph.nodes[i];
    const geo = new THREE.SphereGeometry(n.r, 16, 12);
    const mesh = new THREE.Mesh(geo, nodeMat);
    mesh.userData.baseScale = 1;
    mesh.position.set(n.x, n.y, n.z);
    mesh.userData.node = n;
    n.mesh = mesh;
    meshes.push(mesh);
    scene.add(mesh);
  }

  const nodeById = Object.create(null);
  for (let i = 0; i < graph.nodes.length; i++)
  {
    nodeById[graph.nodes[i].id] = graph.nodes[i];
  }

  function pickMainNode()
  {
    let best = null;
    for (let i = 0; i < graph.nodes.length; i++)
    {
      const n = graph.nodes[i];
      if (!best) best = n;
      else if (n.out_calls > best.out_calls) best = n;
      else if (n.out_calls === best.out_calls)
      {
        const nt = n.in_calls + n.out_calls;
        const bt = best.in_calls + best.out_calls;
        if (nt > bt) best = n;
      }
    }
    return best;
  }

  const listModel = graph.nodes.slice().sort(function(a, b)
  {
    // Most connected first
    const ca = (a.in_calls + a.out_calls);
    const cb = (b.in_calls + b.out_calls);
    if (cb !== ca) return cb - ca;
    return a.name.localeCompare(b.name);
  });

  // Fat edges: cylinders between nodes (radius scales with edge weight)
  const edgeMat = new THREE.MeshBasicMaterial({ color: 0x8aa1b1, transparent: true, opacity: 0.35 });
  const edgeMeshes = [];

  function edgeRadius(w)
  {
    const ww = (typeof w === "number") ? w : 1;
    return 0.25 + Math.min(2.6, ww * 0.28);
  }

  function edgeOpacity(w)
  {
    const ww = (typeof w === "number") ? w : 1;
    return 0.18 + Math.min(0.70, ww * 0.06);
  }

  const up = new THREE.Vector3(0, 1, 0);
  const dir = new THREE.Vector3();
  const mid = new THREE.Vector3();
  const qa = new THREE.Quaternion();

  function buildEdgeMeshes()
  {
    for (let i = 0; i < graph.edges.length; i++)
    {
      const e = graph.edges[i];
      const r = edgeRadius(e.count);

      // Placeholder height; we scale Y each frame to match actual length
      const geo = new THREE.CylinderGeometry(r, r, 1, 10, 1, true);
      const mat = edgeMat.clone();
      mat.opacity = edgeOpacity(e.count);

      const mesh = new THREE.Mesh(geo, mat);
      mesh.userData.edge = e;
      e.mesh = mesh;
      edgeMeshes.push(mesh);
      scene.add(mesh);
    }
  }

  function updateEdgeMeshes()
  {
    for (let i = 0; i < graph.edges.length; i++)
    {
      const e = graph.edges[i];
      const m = e.mesh;
      if (!m) continue;

      const ax = e.s.x;
      const ay = e.s.y;
      const az = e.s.z;
      const bx = e.t.x;
      const by = e.t.y;
      const bz = e.t.z;

      dir.set(bx - ax, by - ay, bz - az);
      const len = dir.length();
      if (len < 0.0001) continue;

      mid.set((ax + bx) * 0.5, (ay + by) * 0.5, (az + bz) * 0.5);
      m.position.copy(mid);

      // Orient cylinder's Y axis to the direction
      dir.normalize();
      qa.setFromUnitVectors(up, dir);
      m.quaternion.copy(qa);

      // CylinderGeometry height is 1; scale Y to actual length
      m.scale.set(1, len, 1);
    }
  }

  buildEdgeMeshes();

  // Edge adjacency: quickly compute the number of connections between two nodes
  const edgeCountByPair = Object.create(null);
  for (let i = 0; i < graph.edges.length; i++)
  {
    const e = graph.edges[i];
    const k1 = e.s.id + "->" + e.t.id;
    edgeCountByPair[k1] = e.count || 1;
  }

  // Build runtime call steps by inverting the existing invoke_list callsites.
  // invoke_list lives on the CALLEE; invoke.line points at the CALLSITE in the caller.
  const outgoingByCaller = Object.create(null);
  const funcByName = Object.create(null);
  for (let i = 0; i < (DATA.functions || []).length; i++)
  {
    const f = DATA.functions[i];
    if (f && f.function_name) funcByName[f.function_name] = f;
  }

  const spansForCaller = graph.nodes.slice().sort(function(a, b)
  {
    if (a.start_line !== b.start_line) return a.start_line - b.start_line;
    return a.end_line - b.end_line;
  });

  function findCallerNodeByLine(line)
  {
    // Reuse the same approach as buildGraph, but scoped here for runtime.
    if (typeof line !== "number") return null;

    let lo = 0;
    let hi = spansForCaller.length - 1;
    let bestIdx = -1;

    while (lo <= hi)
    {
      const mid = (lo + hi) >> 1;
      const s = spansForCaller[mid].start_line;
      if (s <= line)
      {
        bestIdx = mid;
        lo = mid + 1;
      }
      else hi = mid - 1;
    }

    if (bestIdx < 0) return null;

    let best = null;
    for (let i = bestIdx; i >= 0; i--)
    {
      const n = spansForCaller[i];
      if (n.start_line > line) continue;
      if (n.end_line < line) break;

      if (!best) best = n;
      else
      {
        const bestSize = best.end_line - best.start_line;
        const nSize = n.end_line - n.start_line;
        if (nSize < bestSize) best = n;
      }
    }

    return best;
  }

  function addOutgoingStep(callerNode, calleeName, call)
  {
    if (!callerNode || !calleeName) return;
    const list = outgoingByCaller[callerNode.id] || [];
    list.push({
      caller: callerNode.id,
      callee: calleeName,
      line: (typeof call.line === "number") ? call.line : 0,
      context: call.context || "single",
      loop_header_preview: call.loop_header_preview || "",
      args_preview: call.args_preview || ""
    });
    outgoingByCaller[callerNode.id] = list;
  }

  for (let i = 0; i < (DATA.functions || []).length; i++)
  {
    const f = DATA.functions[i];
    const inv = (f.invokes && f.invokes.invoke_list) ? f.invokes.invoke_list : [];
    const callee = f.function_name;

    for (let k = 0; k < inv.length; k++)
    {
      const call = inv[k];
      const callerNode = findCallerNodeByLine(call.line);
      addOutgoingStep(callerNode, callee, call);
    }
  }

  for (const k in outgoingByCaller)
  {
    outgoingByCaller[k].sort(function(a, b)
    {
      return a.line - b.line;
    });
  }

  // Picking
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let hoverNode = null;
  let selectedNode = null;
  let hoverEdge = null;
  let selectedEdge = null;

  function setHover(n)
  {
    if (hoverNode === n) return;
    if (hoverNode && hoverNode.mesh)
    {
      if (selectedNode === hoverNode) hoverNode.mesh.material = selMat;
      else hoverNode.mesh.material = nodeMat;
    }
    hoverNode = n;
    if (hoverNode && hoverNode.mesh)
    {
      if (selectedNode === hoverNode) hoverNode.mesh.material = selMat;
      else hoverNode.mesh.material = hoverMat;
    }
  }

  function setSelected(n)
  {
    if (selectedNode && selectedNode.mesh)
    {
      selectedNode.mesh.material = nodeMat;
    }
    selectedNode = n;
    if (selectedNode && selectedNode.mesh)
    {
      selectedNode.mesh.material = selMat;
    }
  }

  function clearRuntimeHighlight()
  {
    for (let i = 0; i < graph.nodes.length; i++)
    {
      const n = graph.nodes[i];
      if (!n.mesh) continue;

      // Preserve hover/selection visuals when in Functions domain.
      if (selectedNode === n) n.mesh.material = selMat;
      else if (hoverNode === n) n.mesh.material = hoverMat;
      else n.mesh.material = nodeMat;

      if (n.mesh.userData && typeof n.mesh.userData.baseScale === "number")
      {
        const bs = n.mesh.userData.baseScale;
        n.mesh.scale.set(bs, bs, bs);
      }
    }

    for (let i = 0; i < graph.edges.length; i++)
    {
      const e = graph.edges[i];
      if (!e.mesh) continue;
      if (e.mesh.userData && e.mesh.userData.baseOpacity != null)
      {
        e.mesh.material.opacity = e.mesh.userData.baseOpacity;
      }
    }
  }

  function applyRuntimeHighlight(step)
  {
    if (!step) return;

    const caller = nodeById[step.caller];
    const callee = nodeById[step.callee];

    if (caller && caller.mesh)
    {
      caller.mesh.material = rtActiveMat;
    }

    if (callee && callee.mesh)
    {
      callee.mesh.material = rtCalleeMat;
    }

    // Edge highlight if present
    for (let i = 0; i < graph.edges.length; i++)
    {
      const e = graph.edges[i];
      if (e.s.id === step.caller && e.t.id === step.callee)
      {
        if (e.mesh)
        {
          if (e.mesh.userData && e.mesh.userData.baseOpacity == null)
          {
            e.mesh.userData.baseOpacity = e.mesh.material.opacity;
          }
          e.mesh.material.opacity = Math.min(0.95, (e.mesh.userData.baseOpacity || 0.35) + 0.35);
        }
        break;
      }
    }
  }
  // Runtime playback (logic trace) state
  let rtMain = null;
  let rtSteps = [];
  let rtIndex = 0;
  let rtPlaying = false;
  let rtAccum = 0;
  let rtPulseT = 0;

  function buildRuntimeSteps()
  {
    rtMain = pickMainNode();
    rtSteps = (rtMain && outgoingByCaller[rtMain.id]) ? outgoingByCaller[rtMain.id].slice() : [];
    rtIndex = 0;

    if (rtInfo)
    {
      if (!rtMain) rtInfo.textContent = "No functions available.";
      else
      {
        rtInfo.textContent = "Main: " + rtMain.id + "  (lines " + rtMain.start_line + "-" + rtMain.end_line + ")";
      }
    }

    renderRuntimeList();
    updateRuntimeControls();
  }

  function updateRuntimeControls()
  {
    if (!rtStepLabel) return;
    const total = rtSteps.length;
    const idxHuman = total ? (rtIndex + 1) : 0;
    rtStepLabel.textContent = idxHuman + " / " + total;
    rtPlay.textContent = rtPlaying ? "Pause" : "Play";
  }

  function renderRuntimeList()
  {
    if (!rtStepsEl) return;

    const parts = [];
    for (let i = 0; i < rtSteps.length; i++)
    {
      const s = rtSteps[i];
      const cls = (i === rtIndex) ? "rtrow active" : "rtrow";
      const txt = "CALL " + s.callee + "(" + (s.args_preview || "") + ")";
      parts.push(
        '<div class="' + cls + '" data-rt="' + i + '">' +
          '<div class="ln">line ' + s.line + '</div>' +
          '<div class="txt">' + escapeHtml(txt) + '</div>' +
        '</div>'
      );
    }

    if (!parts.length)
    {
      parts.push('<div style="opacity:0.85">No steps found for main function. (No callsites resolved.)</div>');
    }

    rtStepsEl.innerHTML = parts.join("");
  }

  function clampRtIndex()
  {
    if (rtIndex < 0) rtIndex = 0;
    if (rtIndex > rtSteps.length - 1) rtIndex = Math.max(0, rtSteps.length - 1);
  }

  function setRtIndex(i)
  {
    rtIndex = i;
    clampRtIndex();
    renderRuntimeList();
    updateRuntimeControls();
  }

  function stepRt(delta)
  {
    if (!rtSteps.length) return;
    rtIndex += delta;
    if (rtIndex < 0) rtIndex = 0;
    if (rtIndex >= rtSteps.length) rtIndex = rtSteps.length - 1;
    renderRuntimeList();
    updateRuntimeControls();
  }

  function fmtNode(n)
  {
    if (!n) return "";
    const a = [];
    a.push(n.name);
    a.push("lines: " + n.start_line + "-" + n.end_line);
    a.push("calls out: " + n.out_calls + " | calls in: " + n.in_calls);
    return a.join("\n");
  }

  function updateHUD()
  {
    if (viewMode !== "3d")
    {
      if (domainMode === "runtime")
      {
        hudLeft.textContent = "Runtime / List. No runtime data loaded yet.";
      }
      else
      {
        hudLeft.textContent = "Functions / List. Search and click a function to focus it in 3D.";
      }
      hudCenter.textContent = "";
      hudRight.textContent = "";
      return;
    }

    // 3D view: domain-specific guidance when nothing is selected
    if (domainMode === "runtime" && !hoverNode && !selectedNode && !hoverEdge && !selectedEdge)
    {
      hudLeft.textContent = "Runtime / 3D. No runtime data loaded yet.";
      hudCenter.textContent = "";
      hudRight.textContent = "";
      return;
    }

    // Default text
    if (!hoverNode && !selectedNode && !hoverEdge && !selectedEdge)
    {
      hudLeft.textContent = "Drag to orbit. Scroll to zoom. Click a node or edge.";
      hudCenter.textContent = "";
      hudRight.textContent = "";
      return;
    }

    // Prefer a selected edge over node hover
    const e = selectedEdge || hoverEdge;
    if (e)
    {
      hudLeft.textContent = fmtNode(e.s);
      hudRight.textContent = fmtNode(e.t);

      const c = (typeof e.count === "number") ? e.count : 1;
      const mid = [];
      mid.push("connections");
      mid.push(String(c));
      mid.push("edges: " + graph.edges.length);
      mid.push("unresolved: " + graph.meta.unresolved_calls);
      hudCenter.textContent = mid.join("\n");
      return;
    }

    // Otherwise show a single node (hover or selected) on the left
    const n = hoverNode || selectedNode;
    hudLeft.textContent = fmtNode(n);
    hudCenter.textContent = "";
    hudRight.textContent = "";
  }

  function applyUIState()
  {
    const isList = (viewMode === "list");

    domainFunctions.classList.toggle("active", domainMode === "functions");
    domainRuntime.classList.toggle("active", domainMode === "runtime");
    view3d.classList.toggle("active", viewMode === "3d");
    viewList.classList.toggle("active", isList);

    // Panels: listpanel is for List view in Functions domain.
    // runtimepanel is for List view in Runtime domain (placeholder until data exists).
    listPanel.style.display = (domainMode === "functions" && isList) ? "block" : "none";
    runtimePanel.style.display = (domainMode === "runtime" && isList) ? "block" : "none";

    // Search only visible in List view and only useful in Functions domain
    searchEl.style.display = (domainMode === "functions" && isList) ? "block" : "none";

    rtControls.style.display = (domainMode === "runtime" && viewMode === "3d") ? "flex" : "none";

    // Orbit controls only enabled in 3D view (either domain)
    controls.enabled = (viewMode === "3d");

    if (domainMode === "functions" && isList) renderList();

    // If we leave Runtime/3D, stop playback.
    if (!(domainMode === "runtime" && viewMode === "3d"))
    {
      rtPlaying = false;
      rtAccum = 0;
    }

    // Ensure highlight state matches current mode.
    if (domainMode !== "runtime" || viewMode !== "3d")
    {
      clearRuntimeHighlight();
    }
    else
    {
      if (rtSteps.length) {
        clearRuntimeHighlight();
        applyRuntimeHighlight(rtSteps[rtIndex]);
      }
    }

    updateHUD();
  }

  function setDomain(mode)
  {
    domainMode = mode;
    applyUIState();
  }

  function setView(mode)
  {
    viewMode = mode;
    applyUIState();
  }

  function renderList()
  {
    const q = String(searchEl.value || "").trim().toLowerCase();
    let shown = 0;

    const parts = [];
    for (let i = 0; i < listModel.length; i++)
    {
      const n = listModel[i];
      if (q)
      {
        const hay = (n.name || "").toLowerCase();
        if (hay.indexOf(q) === -1) continue;
      }

      const total = (n.in_calls + n.out_calls);
      parts.push(
        '<div class="row" data-id="' + n.id + '">' +
          '<div class="name">' + escapeHtml(n.name) + '</div>' +
          '<div class="muted">' + n.start_line + '-' + n.end_line + '</div>' +
          '<div class="muted">in ' + n.in_calls + ' out ' + n.out_calls + '</div>' +
          '<div class="muted">total ' + total + '</div>' +
        '</div>'
      );
      shown++;
    }

    listEl.innerHTML = parts.join("");
    listMeta.textContent = shown + " / " + listModel.length + " shown";
  }

  function escapeHtml(s)
  {
    return String(s)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  function focusNode(n)
  {
    if (!n) return;

    selectedEdge = null;
    setSelected(n);

    // Move the orbit target and camera near the node
    controls.target.set(n.x, n.y, n.z);
    const v = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
    const t = new THREE.Vector3(n.x, n.y, n.z);
    const dir = v.sub(controls.target);
    if (dir.length() < 0.001) dir.set(0, 0, 900);
    dir.setLength(700);
    camera.position.set(t.x + dir.x, t.y + dir.y, t.z + dir.z);

    updateHUD();
  }

  domainFunctions.addEventListener("click", function()
  {
    setDomain("functions");
  });

  domainRuntime.addEventListener("click", function()
  {
    setDomain("runtime");
  });

  view3d.addEventListener("click", function()
  {
    setView("3d");
  });

  viewList.addEventListener("click", function()
  {
    setView("list");
  });

  searchEl.addEventListener("input", function()
  {
    if (viewMode === "list") renderList();
  });

  listEl.addEventListener("click", function(ev)
  {
    const t = ev.target;
    const row = t && t.closest ? t.closest(".row") : null;
    if (!row) return;
    const id = row.getAttribute("data-id");
    if (!id) return;
    const n = nodeById[id];
    if (!n) return;

    // Jump back to Functions / 3D view and focus
    setDomain("functions");
    setView("3d");
    focusNode(n);
  });

  rtPrev.addEventListener("click", function()
  {
    rtPlaying = false;
    stepRt(-1);
  });

  rtNext.addEventListener("click", function()
  {
    rtPlaying = false;
    stepRt(1);
  });

  rtPlay.addEventListener("click", function()
  {
    rtPlaying = !rtPlaying;
    updateRuntimeControls();
  });

  rtStepsEl.addEventListener("click", function(ev)
  {
    const t = ev.target;
    const row = t && t.closest ? t.closest(".rtrow") : null;
    if (!row) return;
    const idx = parseInt(row.getAttribute("data-rt"), 10);
    if (!isNaN(idx))
    {
      rtPlaying = false;
      setRtIndex(idx);
    }
  });

  renderer.domElement.addEventListener("mousemove", function(ev)
  {
    const r = renderer.domElement.getBoundingClientRect();
    mouse.x = ((ev.clientX - r.left) / r.width) * 2 - 1;
    mouse.y = -(((ev.clientY - r.top) / r.height) * 2 - 1);

    raycaster.setFromCamera(mouse, camera);
    const hitNodes = raycaster.intersectObjects(meshes, false);
    const hitEdges = raycaster.intersectObjects(edgeMeshes, false);

    if (hitNodes && hitNodes.length)
    {
      const n = hitNodes[0].object.userData.node;
      setHover(n);
    }
    else
    {
      setHover(null);
    }

    // Track hovered edge (closest hit)
    if (hitEdges && hitEdges.length)
    {
      hoverEdge = hitEdges[0].object.userData.edge;
    }
    else
    {
      hoverEdge = null;
    }

    updateHUD();
  });

  renderer.domElement.addEventListener("click", function()
  {
    if (hoverEdge)
    {
      selectedEdge = hoverEdge;
      // Also select both endpoints for context
      setSelected(null);
    }
    else
    {
      selectedEdge = null;
      if (hoverNode) setSelected(hoverNode);
      else setSelected(null);
    }
    updateHUD();
  });

  window.addEventListener("resize", function()
  {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // 3D force simulation
  function tick()
  {
    const nodes = graph.nodes;
    const edges = graph.edges;

    const repulsion = 14000;
    const springK = 0.0022;
    const springLen = 160;
    const damping = 0.86;

    // pairwise repulsion
    for (let i = 0; i < nodes.length; i++)
    {
      for (let j = i + 1; j < nodes.length; j++)
      {
        const a = nodes[i];
        const b = nodes[j];

        let dx = a.x - b.x;
        let dy = a.y - b.y;
        let dz = a.z - b.z;

        let d2 = dx*dx + dy*dy + dz*dz + 0.01;
        const f = repulsion / d2;
        const invD = 1 / Math.sqrt(d2);

        dx *= invD;
        dy *= invD;
        dz *= invD;

        a.vx += dx * f;
        a.vy += dy * f;
        a.vz += dz * f;

        b.vx -= dx * f;
        b.vy -= dy * f;
        b.vz -= dz * f;
      }
    }

    // springs
    for (let i = 0; i < edges.length; i++)
    {
      const e = edges[i];
      const a = e.s;
      const b = e.t;
      const w = (typeof e.count === "number") ? e.count : 1;

      let dx = b.x - a.x;
      let dy = b.y - a.y;
      let dz = b.z - a.z;

      const d = Math.sqrt(dx*dx + dy*dy + dz*dz) + 0.0001;
      const stretch = d - springLen;
      const f = stretch * springK * Math.min(6.0, 1.0 + w * 0.25);

      dx /= d;
      dy /= d;
      dz /= d;

      a.vx += dx * f;
      a.vy += dy * f;
      a.vz += dz * f;

      b.vx -= dx * f;
      b.vy -= dy * f;
      b.vz -= dz * f;
    }

    // integrate
    for (let i = 0; i < nodes.length; i++)
    {
      const n = nodes[i];

      n.vx *= damping;
      n.vy *= damping;
      n.vz *= damping;

      n.x += n.vx;
      n.y += n.vy;
      n.z += n.vz;

      if (n.mesh)
      {
        n.mesh.position.set(n.x, n.y, n.z);
      }
    }

    updateEdgeMeshes();
  }

  function frame()
  {
    // Runtime playback tick (no real timing; just steady stepping)
    if (domainMode === "runtime" && viewMode === "3d" && rtSteps.length)
    {
      const spd = parseFloat(rtSpeed.value || "1") || 1;
      const dt = 1 / 60;

      if (rtPlaying)
      {
        rtAccum += dt * spd;
        if (rtAccum >= 0.9)
        {
          rtAccum = 0;
          if (rtIndex < rtSteps.length - 1) rtIndex++;
          else rtPlaying = false;
          renderRuntimeList();
          updateRuntimeControls();
        }
      }

      rtPulseT += dt * 6.0;
      clearRuntimeHighlight();
      const st = rtSteps[rtIndex];
      applyRuntimeHighlight(st);

      // Pulse the active caller node
      const caller = nodeById[st.caller];
      if (caller && caller.mesh)
      {
        const s = 1.0 + (Math.sin(rtPulseT) * 0.08);
        caller.mesh.scale.set(s, s, s);
      }
    }

    tick();
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(frame);
  }

  buildRuntimeSteps();
  updateEdgeMeshes();
  applyUIState();
  frame();
}

function boot(json)
{
  DATA = json;
  const g = buildGraph(DATA);
  start3D(g);
}

function showLoadError(err, attemptedUrl)
{
  const hud = document.getElementById("hud_left");
  const here = String(window.location.href);
  const lines = [];
  lines.push("Could not load function_intel.json");
  lines.push("page: " + here);
  if (attemptedUrl) lines.push("attempted: " + attemptedUrl);
  lines.push("error: " + String(err));
  lines.push("");
  lines.push("Run a local server from this folder:");
  lines.push("python3 -m http.server 8080");
  lines.push("Then open: http://localhost:8080/index.html");
  hud.textContent = lines.join("\n");
  const hudCenter = document.getElementById("hud_center");
  const hudRight = document.getElementById("hud_right");
  if (hudCenter) hudCenter.textContent = "";
  if (hudRight) hudRight.textContent = "";
  const listPanel = document.getElementById("listpanel");
  if (listPanel) listPanel.style.display = "none";
  const runtimePanel = document.getElementById("runtimepanel");
  if (runtimePanel) runtimePanel.style.display = "none";
}

// Load JSON relative to the current page
const url = new URL("function_intel.json", window.location.href).toString();
fetch(url, { cache: "no-store" })
  .then(r =>
  {
    if (!r.ok) throw new Error("HTTP " + r.status + " " + r.statusText);
    return r.json();
  })
  .then(j => boot(j))
  .catch(err => showLoadError(err, url));
</script>
</body>
</html>
